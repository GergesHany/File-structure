<h1 id="basic-file-processing-operations">Basic File Processing Operations</h1>
<ul>
<li><h4 id="-physical-file-a-collection-of-bytes-stored-on-a-disk-or-tape-"><code>Physical File:</code> A collection of bytes stored on a disk or tape.</h4>
</li>
<li><h4 id="-logical-file-a-channel-like-a-telephone-line-that-hides-the-details-of-the-file-s-location-and-physical-format-to-the-program-"><code>Logical File:</code> A channel (like a telephone line) that hides the details of the file’s location and physical format to the program.</h4>
</li>
<li><h4 id="-iostream-standard-library-which-provides-cin-and-cout-methods-for-reading-from-standard-input-and-writing-to-standard-output-respectively-"><code>iostream</code> standard library , which provides <code>cin and cout</code> methods for reading from standard <code>input and writing</code> to standard output respectively.</h4>
</li>
<li><h4 id="-fstream-is-used-to-read-and-write-from-a-file-you-require-another-standard-c-library-defines-three-new-data-types-"><code>Fstream</code> is used to <code>read and write</code> from a file you require another standard C++ library, defines <code>three new data types</code>.</h4>
</li>
<li><h4 id="fstreams-defines-three-new-data-types-">fstreams defines three new <code>data types</code> :</h4>
</li>
</ul>
<hr>

<table>
<thead>
<tr>
<th style="text-align:center">Data Type</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ofstream</td>
<td style="text-align:center">represents the output file stream. used to create files and to write information to files.</td>
</tr>
<tr>
<td style="text-align:center">ifstream</td>
<td style="text-align:center">represents the input file stream. used to read information from files.</td>
</tr>
<tr>
<td style="text-align:center">fstream</td>
<td style="text-align:center">represents the file stream generally. has the capabilities of both ofstream and ifstream (Can create files, write information to files, and read information from files)</td>
</tr>
</tbody>
</table>
<hr>

<ul>
<li><h4 id="to-perform-file-processing-in-c-header-files-iostream-and-fsteam-must-be-included-in-your-c-source-file">To perform file processing in C++, <code>header files &lt;iostream&gt; and &lt;fsteam&gt;</code> must be included in your C++ source file</h4>
</li>
<li><h4 id="a-file-must-be-opened-before-you-can-read-from-it-or-write-to-it">A file must be opened before you can read from it or write to it</h4>
</li>
<li><h4 id="standard-syntax-for-open-function-is">standard syntax for open () function is</h4>
</li>
</ul>
<pre><code class="lang-bash">void open (<span class="hljs-keyword">const</span> char *filename, ios::openmode mode);

<span class="hljs-keyword">const</span> char * filename specifies the <span class="hljs-keyword">name</span> <span class="hljs-keyword">and</span> location <span class="hljs-keyword">of</span> the <span class="hljs-keyword">file</span> <span class="hljs-keyword">to</span> be opened

ios::openmode mode defines the mode <span class="hljs-keyword">in</span> which the <span class="hljs-keyword">file</span> should be opened
</code></pre>
<hr>

<table>
<thead>
<tr>
<th style="text-align:center">Data Type</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ios::app</td>
<td style="text-align:center"><code>Append</code> mode. All output to that file to be appended to the end.</td>
</tr>
<tr>
<td style="text-align:center">ios::ate</td>
<td style="text-align:center"><code>Open a file</code> for output and move the read/write control to the end of the file</td>
</tr>
<tr>
<td style="text-align:center">ios::in</td>
<td style="text-align:center">Open a file for <code>reading</code></td>
</tr>
<tr>
<td style="text-align:center">ios::out</td>
<td style="text-align:center">Open a file for <code>writing</code></td>
</tr>
<tr>
<td style="text-align:center">ios::trunc</td>
<td style="text-align:center">If the file already exists, its contents will be truncated before opening the file.</td>
</tr>
</tbody>
</table>
<hr>

<ul>
<li><h4 id="if-you-want-to-open-a-file-for-reading-and-writing-purposes-the-following-will-be-the-syntax">If you want to open a file for <code>reading</code> and <code>writing</code> purposes, the following will be the syntax</h4>
</li>
</ul>
<pre><code class="lang-bash">fstream <span class="hljs-keyword">outfile</span>; 
<span class="hljs-keyword">outfile</span>.<span class="hljs-keyword">open</span>(<span class="hljs-string">"file.dat"</span>, ios::<span class="hljs-keyword">out</span> | ios::<span class="hljs-keyword">in</span>);
</code></pre>
<ul>
<li><h4 id="when-a-c-program-terminates-it-automatically-closes-flushes-all-the-streams-releases-all-the-allocated-memory-and-closes-all-the-opened-files-">When a C++ program terminates it <code>automatically closes</code>, flushes all the streams, releases all the allocated memory and closes all the opened files.</h4>
</li>
<li><h4 id="the-following-is-the-standard-syntax-for-close-function-which-is-a-member-of-fstream-ifstream-and-ofstream-objects-void-close-">The following is the <code>standard syntax for close () function</code>, which is a member of fstream, ifstream, and ofstream objects. <code>void close ();</code></h4>
</li>
<li><h4 id="you-can-use-an-ofstream-or-fstream-object-instead-of-the-cout-object">You can use an <code>ofstream or fstream</code> object instead of the <code>cout</code> object</h4>
</li>
<li><h4 id="you-can-use-an-ifstream-or-fstream-object-instead-of-the-cin-object-">You can use an <code>ifstream or fstream</code> object instead of the <code>cin</code> object.</h4>
</li>
<li><h4 id="both-istream-and-ostream-provide-member-functions-for-repositioning-the-file-position-pointer-are-seekg-seek-get-for-istream-and-seekp-seek-put-for-ostream-">Both istream and ostream provide member functions for repositioning the file-position pointer, are <code>seekg (&quot;seek get&quot;) for istream</code> and <code>seekp (&quot;seek put&quot;) for ostream.</code></h4>
</li>
<li><h4 id="the-first-argument-to-seekg-and-seekp-normally-is-a-long-integer-">The first argument to <code>seekg and seekp</code> normally is a <code>long integer</code></h4>
</li>
<li><h4 id="a-second-argument-can-be-specified-to-indicate-the-seek-direction-">A second argument can be <code>specified to indicate the seek direction</code>.</h4>
</li>
<li><h4 id="the-seek-direction-can-be-">The seek direction can be:</h4>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">Data Type</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ios::beg</td>
<td style="text-align:center">for positioning relative <code>to the beginning</code> of a stream.</td>
</tr>
<tr>
<td style="text-align:center">ios::cur</td>
<td style="text-align:center">for positioning relative <code>to the current position</code> in a stream</td>
</tr>
<tr>
<td style="text-align:center">ios::end</td>
<td style="text-align:center">for positioning relative to the <code>end</code> of a stream</td>
</tr>
</tbody>
</table>
<h2 id="-cd-rom-"><strong>CD-ROM</strong></h2>
<ul>
<li><h4 id="-a-single-disc-can-hold-more-than-600-megabytes-of-data-"><code>A single disc</code> can hold more than 600 megabytes of data.</h4>
</li>
<li><h4 id="data-is-encoded-and-read-optically-with-a-laser-beam-">Data is encoded and read optically with a <code>laser beam.</code></h4>
</li>
<li><h4 id="-cd-rom-is-read-only-or-write-once-i-e-once-it-has-been-recorded-it-can-t-be-changed-"><code>CD-ROM</code> is read only (or write once). i.e., once it has been recorded; it can’t be changed.</h4>
</li>
<li><h4 id="-cd-rom-is-a-publishing-medium-rather-than-a-data-storage-and-retrieval-like-magnetic-disks-"><code>CD-ROM</code> is a publishing medium rather than a data storage and retrieval like magnetic disks.</h4>
</li>
<li><h4 id="-cd-rom-strengths-high-storage-capacity-inexpensive-price-durability-"><code>CD-ROM</code> Strengths: High storage capacity, inexpensive price, durability.</h4>
</li>
<li><h4 id="-cd-rom-weaknesses-extremely-slow-seek-performance-between-l-2-a-second-to-a-second-"><code>CD-ROM</code> Weaknesses: extremely slow seek performance (between l/2 a second to a second)</h4>
</li>
</ul>
<hr>

<h2 id="intelligent-file-structures-are-critical-">Intelligent File Structures are critical.</h2>
<ul>
<li><h4 id="-cd-rom-is-a-descendent-of-cd-audios-"><code>CD-ROM</code> is a descendent of CD Audios.</h4>
</li>
<li><h4 id="listening-to-music-is-sequential-and-does-not-require-fast-random-access-to-data-">Listening to music is sequential and does not require fast random access to data.</h4>
</li>
<li><h4 id="-cd-roms-are-stamped-from-a-glass-master-disk-which-has-a-nickel-coating-that-is-changed-by-the-laser-beam-"><code>CD-ROMs</code> are stamped from a glass master disk which has a nickel coating that is changed by the <code>laser beam</code>.</h4>
</li>
<li><h4 id="when-the-coating-is-developed-the-areas-hit-by-the-laser-beam-turn-into-pits-along-the-track-followed-by-the-beam-">When the coating is developed, the areas hit by the laser beam turn into <code>pits</code> along the track followed by the beam.</h4>
</li>
<li><h4 id="the-smooth-unchanged-areas-between-the-pits-are-called-lands-">The smooth unchanged areas between the pits are called <code>lands</code>.</h4>
</li>
<li><h4 id="-digital-data-is-represented-as-a-series-of-pits-and-lands-"><code>Digital data</code> is represented as a series of Pits and Lands.</h4>
</li>
<li><h4 id="-pit-a-little-depression-forming-a-lower-level-in-the-track-"><code>Pit</code> a little depression, forming a lower level in the track.</h4>
</li>
<li><h4 id="-land-the-part-between-pits-or-the-upper-levels-in-the-track-"><code>Land</code> the part between pits, or the upper levels in the track.</h4>
</li>
<li><h4 id="when-we-read-the-stamped-copy-of-the-disk-we-focus-a-beam-of-laser-light-on-the-track-as-it-moves-under-the-optical-pickup-">When we read the stamped copy of the disk: We focus a beam of laser light on the track as it moves under the <code>optical pickup</code>.</h4>
</li>
<li><h4 id="-the-pits-scatter-the-light-but-t-he-lands-reflect-most-of-it-back-to-the-pickup-"><code>The pits</code> scatter the light, but t<code>he lands</code> reflect most of it, back to the pickup.</h4>
</li>
<li><h4 id="this-alternating-pattern-of-high-intensity-and-low-intensity-reflected-light-is-the-signal-used-to-reconstruct-the-original-digital-information-">This alternating pattern of high-intensity and low-intensity <code>reflected light</code> is the signal used to reconstruct the original digital information.</h4>
</li>
<li><h4 id="-1-s-is-represented-by-the-transition-from-pit-to-land-and-back-again-"><code>1’s</code> is represented by the transition from pit to land and back again.</h4>
</li>
<li><h4 id="-0-s-is-represented-by-the-amount-of-time-between-transitions-"><code>0’s</code> is represented by the amount of time between transitions.</h4>
</li>
<li><h4 id="the-longer-between-transitions-the-more-0-s-we-have">The longer between transitions, the more 0 s we have</h4>
</li>
</ul>
<hr>

<ul>
<li><h4 id="raw-patterns-of-1-s-and-0-s-must-be-translated-to-get-the-8-bit-patterns-of-ls-and-0s-that-form-the-bytes-of-the-original-data-">Raw patterns of <code>1 s</code> and <code>0</code>s must be translated to  get the 8-bit patterns of ls and 0s that form the  bytes of the original data.</h4>
</li>
<li><h4 id="-efm-encoding-eight-to-fourteen-modulations-turns-the-original-8-bits-of-data-into-i4-expanded-bits-that-can-be-represented-in-the-pits-and-lands-on-the-disk-"><code>EFM encoding</code> (Eight to Fourteen Modulations) turns the original 8 bits of data into I4 expanded bits that can be represented in the pits and lands on the disk.</h4>
</li>
<li><h4 id="since-0-s-are-represented-by-the-length-of-time-between-transition-the-disk-must-be-rotated-at-a-precise-and-constant-speed-">Since <code>0 s</code> are represented by the length of time between transition, the disk must be rotated at a precise and constant speed.</h4>
</li>
<li><h4 id="this-affects-the-cd-rom-drive-s-ability-to-seek-quickly-">This affects the CD-ROM drive’s ability to seek quickly.</h4>
</li>
<li><h4 id="a-key-assembly-in-a-compact-disc-player-is-the-optical-pick-up-assembly-">A key assembly in a compact disc player is <code>the optical pick-up assembly.</code></h4>
</li>
<li><h4 id="-the-optical-pick-up-is-situated-on-rails-so-that-it-can-move-back-and-forth-underneath-the-compact-disc"><code>The optical pick-up</code> is situated on rails so that it can move back and forth underneath the compact disc</h4>
</li>
<li><h4 id="-the-optical-pick-up-works-by-directing-a-laser-beam-at-the-cd-if-the-laser-hits-land-the-reflected-light-then-travels-to-the-photodiode-which-generates-an-electrical-signal-"><code>The optical pick-up</code> works by directing a laser beam at the CD, if the laser hits land, the reflected light then travels to the <code>photodiode</code>,  which <code>generates an electrical signal.</code></h4>
</li>
</ul>
<hr>

<ul>
<li><h4 id="ln-turn-the-signal-moves-to-the-cd-player-s-circuit-board-to-generate-the-original-signal-">ln turn, the signal moves to the CD player&#39;s <code>circuit board</code> to <code>generate the original signal.</code></h4>
</li>
<li><h4 id="the-space-on-a-computer-disk-is-arranged-into-individually-addressable-areas-called-sectors-">The space on a computer disk is arranged into individually addressable areas called <code>sectors.</code></h4>
</li>
<li><h4 id="there-are-two-basic-methods-for-arranging-these-sectors-on-a-disk-constant-angular-velocity-cav-and-constant-linear-velocity-clv-">There are two basic methods for arranging these sectors on a disk: <code>constant angular velocity (CAV)</code> and <code>constant linear velocity (CLV)</code></h4>
</li>
<li><h4 id="-cav-sectors-are-placed-in-concentric-rings-called-tracks-of-equal-angle-per-sector-"><code>CAV:</code> Sectors are placed in concentric rings (called <code>tracks</code>) of <code>equal angle per sector</code></h4>
</li>
<li><h4 id="-civ-sectors-are-places-in-a-spiral-with-the-physical-length-of-sectors-along-the-disk-kept-constant-instead-of-the-angle-"><code>CIV:</code> Sectors are places in a spiral with the physical length of sectors along the disk kept constant instead of the angle.</h4>
</li>
<li><h4 id="-disks-arranged-into-discrete-tracks-including-floppy-discs-_-dvds-and-hard-drives-are-cav-disks-">`Disks arranged into discrete tracks** (including floppy discs_ DVDs, and hard drives) are CAV disks:</h4>
</li>
<li><h4 id="-the-cav-disk-spins-at-a-fixed-rate-this-means-that-sectors-at-the-outside-of-the-disk-pass-under-the-pick-up-much-faster-than-those-at-the-center-and-thus-the-data-is-spread-out-more-these-wastes-physical-space-on-the-disc-"><code>The CAV disk spins</code> at a fixed rate. This means that sectors at the outside of the disk pass under the pick-up much faster than those at the center, and thus the data is spread out more. These wastes physical space on the disc.</h4>
</li>
<li><h4 id="-cd-_roms-have-a-single-spiral-track-and-are-clv-disks-"><code>CD\_ROMs</code> have a single, spiral track and are CLV disks.</h4>
</li>
<li><h4 id="-cd-roms-rotate-at-a-constant-linear-velocity-of-about-one-meter-per-second-this-requires-that-the-cd-rom-turns-slower-as-the-read-head-moves-to-the-outer-edge-of-the-disk-"><code>CD-ROMs</code> rotate at a constant linear velocity of about one <code>meter per second</code> This requires that the (CD-ROM turns slower as the read head moves to the outer edge of the disk.</h4>
</li>
<li><h4 id="-the-clv-format-is-responsible-in-large-part-for-the-poor-seeking-performance-of-cd-rom-drives-there-is-no-straightforward-way-to-jump-to-a-location-part-of-the-problem-is-the-need-to-change-rotational-speed-"><code>The CLV format</code> is responsible, in large part, for the poor seeking performance of CD-ROM Drives: There is no straightforward way to jump to a location. Part of the problem is the need to change rotational speed.</h4>
</li>
<li><h4 id="to-read-the-address-info-that-is-stored-on-the-disk-along-with-the-user-s-data-we-need-to-be-moving-the-data-under-the-optical-pick-up-at-the-correct-speed-but-to-know-how-to-adjust-the-speed-we-need-to-be-able-to-read-the-address-info-so-we-know-where-we-are-">To read the address info that is stored on the disk along with the user&#39;s data, we need to be moving the data under the optical pick up at the correct speed. But to know how to adjust the speed, we need to be able to read the address info, so we know where we are.</h4>
</li>
<li><h4 id="how-do-we-break-this-loop-by-guessing-and-through-trial-and-error-slows-down-performance-">How do we break this loop? By guessing and through <code>trial and error</code> ==&gt; Slows down performance.</h4>
</li>
<li><h4 id="-in-stream-files-the-information-is-written-as-a-stream-of-bytes-containing-no-added-information-data-semantics-is-lost-"><code>In Stream Files</code>, the information is written as a stream of bytes containing no added information, Data semantics is lost.</h4>
</li>
<li><h4 id="the-basic-logical-unit-of-data-is-the-field-which-contains-a-single-data-value-">The basic logical unit of data is the <code>field</code> which contains a single data value.</h4>
</li>
<li><h4 id="-the-field-is-the-smallest-logically-meaningful-unit-of-information-in-a-file-"><code>The Field</code> is the smallest logically meaningful unit of information in a file.</h4>
</li>
<li><h4 id="-fields-are-organized-into-aggregates-either-as-many-copies-of-a-single-field-an-array-or-as-a-list-of-different-fields-a-record-"><code>Fields</code> are organized into aggregates, either as many copies of a single field (an <code>array</code>) or as a list of different fields (a <code>record</code>)</h4>
</li>
<li><h4 id="-object-is-record-is-stored-in-memory-"><code>Object is</code> record is stored in memory.</h4>
</li>
<li><h4 id="-members-are-record-is-stored-in-fields"><code>Members</code> are record is stored in Fields</h4>
</li>
<li><h4 id="-a-record-can-be-defined-as-a-set-of-fields-that-belong-together-when-the-file-is-viewed-in-terms-of-a-higher-level-of-organization-"><code>A record</code> can be defined as a set of fields that belong together when the file is viewed in terms of a higher level of organization.</h4>
</li>
<li><h4 id="-the-term-object-refers-to-data-residing-in-memory-and-the-term-record-refers-to-data-residing-in-file-"><code>The term object</code> refers to data residing in memory, and <code>the term record</code> refers to data residing in file.</h4>
</li>
<li><h4 id="-fixed-length-records-variable-length-records-are-methods-for-organizing-records-in-a-file-"><code>Fixed-length records &amp; Variable-length records</code> are methods for organizing records in a file.</h4>
</li>
<li><h4 id="-in-fixed-length-records-requiring-that-the-records-be-a-predictable-number-of-bytes-in-length-"><code>In Fixed-length records:</code> Requiring that the records be a predictable number of bytes in length.</h4>
</li>
<li><h4 id="-in-variable-length-records-requiring-that-the-records-be-a-predictable-number-of-fields-in-length-"><code>In Variable-length records:</code> Requiring that the records be a predictable number of fields in length.</h4>
</li>
<li><h4 id="use-an-index-file-to-keep-track-of-record-addresses-the-index-file-keeps-the-byte-offset-for-each-record-this-allows-us-to-search-the-index-which-has-fixed-length-records-in-order-to-discover-the-beginning-of-the-record-">Use an index file to keep track of record addresses: The index file keeps the byte offset for each record; this allows us to search the index (which has fixed length records) in order to discover the beginning of the record.</h4>
</li>
</ul>
<hr>


<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th><strong>CD-ROM</strong></th>
<th><strong>Magnetic Disks</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Ex:</strong></td>
<td><strong>CLV</strong> (Constant Linear Velocity).</td>
<td><strong>CAV</strong> (Constant Angular Velocity)</td>
</tr>
<tr>
<td style="text-align:left">Shape it</td>
<td>Sectors organized along a <strong>spiral</strong>.</td>
<td>Sectors organized in <strong>concentric track</strong>.</td>
</tr>
<tr>
<td style="text-align:left">Length</td>
<td>Sectors have <strong>the same linear length.</strong></td>
<td>Sectors have <strong>the same Angular length.</strong></td>
</tr>
</tbody>
</table>
<hr>

<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>(Data packed at its <strong>max density</strong> permitted)</th>
<th>(Data written <strong>less densely in the outer tracks)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Advantage</td>
<td>It <strong>uses</strong> up all storage <strong>available</strong>.</td>
<td>Operates at <strong>constant speed, timing marks to delimit tracks</strong>.</td>
</tr>
<tr>
<td style="text-align:left">Disadvantage</td>
<td>Must <strong>change rotational speed</strong> when seeking (slower towards the outside)</td>
<td>It <strong>doesn’t use</strong> up all the storage <strong>available</strong>.</td>
</tr>
</tbody>
</table>
<hr>

<table>
<thead>
<tr>
<th><strong>Types</strong></th>
<th><strong>Advantages</strong></th>
<th><strong>Disadvantages</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Fixed</td>
<td>Easy to <strong>read &amp; store.</strong></td>
<td><strong>Waste space</strong> with <strong>padding</strong>.</td>
</tr>
<tr>
<td>With length indicator</td>
<td>Easy to <strong>jump ahead to the end of the field</strong>.</td>
<td><strong>Long fields require more than 1 byte</strong> to store length (<strong>when max size is &gt; 256</strong>)</td>
</tr>
<tr>
<td>Delimited Fields</td>
<td>May <strong>Waste less space</strong> than with length-based</td>
<td><strong>Must check every byte of field</strong> against the delinter</td>
</tr>
<tr>
<td>keyword</td>
<td><strong>Fields are self-describing</strong>, <strong>allowing for missing fields.</strong></td>
<td><strong>Waste space</strong> with <strong>keywords</strong></td>
</tr>
</tbody>
</table>
<hr>

<table>
<thead>
<tr>
<th><strong>Type</strong></th>
<th><strong>Advantages</strong></th>
<th><strong>Disadvantages</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Fixed length record</td>
<td>Easy to <strong>jump to the i-th</strong> record.</td>
<td><strong>Waste space</strong> with padding.</td>
</tr>
<tr>
<td>Variable-length record</td>
<td><strong>Saves space</strong> when record sizes are diverse</td>
<td><strong>Cannot jump to the i-th</strong> record, unless through an index file.</td>
</tr>
</tbody>
</table>
