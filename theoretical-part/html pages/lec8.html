<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>lecture 8</title>
  <style>
      body {
        zoom: 190%;
        font-family: Arial, sans-serif;
        font-size: 18px;
      }

      h1, h2, h3 {
        color: #006699;
        font-weight: bold;
      }

      p {
        color: #006699;
        font-size: 16px;
        line-height: 1.5;
      }

      ul, ol {
        color: black;
        list-style-type: disc;
        margin: 0 0 16px 0;
        padding: 0 0 0 32px;
      }

      li {
        color: black;
        margin-bottom: 8px;
      }


      /* Style the paragraphs */
      p {
      margin: 1em 0;
      line-height: 1.5;
      }

      /* Style the block code */
      pre {
      padding: 1em;
      background-color: #f0f8ff; /* baby blue */
      color: #333;
      overflow-x: auto;
      font-size: 14px;
      line-height: 1.5;
      border-radius: 5px;
      }

      /* Style the code syntax highlighting */
      pre code {
      font-family: Consolas, monospace;
      font-size: 14px;
      }

      /* Style the links */
      a {
      color: #006699; /* darker blue */
      }

      a:hover {
      text-decoration: underline;
      }

      /* Add a background color to the page */
      body {
      background-color: #fff;
      }

      /* Style the header */
      header {
      background-color: #006699; /* darker blue */
      color: #fff; /* white */
      padding: 20px;
      }

      /* Style the names */
      header h1 {
      font-size: 36px;
      margin: 0;
      color: #fff; /* white */
      }

      header h2 {
      font-size: 24px;
      margin: 0;
      color: #f0f8ff; /* baby blue */
      }

      header h3 {
      font-size: 24px;
      margin: 0;
      color: #f0f8ff; /* baby blue */
      }

      header h4 {
      font-size: 24px;
      margin: 0;
      color: #f0f8ff; /* baby blue */
      }

      /* Align the names */
      .names {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      }

      .names h1,
      .names h2 {
      margin: 0 10px;
      }

      /* Add a hover effect to the names */
      .names h1:hover,
      .names h2:hover {
      cursor: pointer;
      text-decoration: underline;
      }


  </style>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><ul>
<li>
<h3 id="key-a-subset-of-the-fields-in-a-record-used-to-identify-uniquely-the-record"><code>Key:</code> a subset of the fields in a record used to identify (uniquely) the record</h3>
<ul>
<li>Primary key: a key that uniquely identifies a record.</li>
<li>Secondary key: other keys that may be used for search.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<h3 id="not-every-field-is-a-key-keys-correspond-to-fields-or-a-combination-of-fields-that-may-be-used-in-a-search">Not every field is a key (keys correspond to fields, or a combination of fields, that may be used in a search)</h3>
</li>
<li>
<h3 id="four-basic-types-of-file-organization">Four basic types of file organization:</h3>
<ul>
<li>Sequential</li>
<li>Indexed</li>
<li>Indexed sequential.</li>
<li>Hashed</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<h4 id="in-all-cases-we-view-a-file-in-a-sequence-of-records.-a-record-is-a-list-of-fields.-each-field-has-a-data-type">In all cases, we view a file in a sequence of records. A record is a list of fields. Each field has a data type</h4>
</li>
<li>
<h3 id="file-operations">File operations:</h3>
<ul>
<li><code>Typical Operations:</code> Retrieve a record - <code>Insert</code> a record - <code>Delete</code> a record – <code>Modify</code> a field of a record</li>
<li><code>In direct files:</code> Get a record with a given field value</li>
<li><code>In sequential</code> files: Get the next record</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<h3 id="sequential-files">Sequential files:</h3>
<ul>
<li>Records are <code>stored contiguously</code> on the storage device.</li>
<li>read from <code>beginning to end</code></li>
<li>Organization of records:
<ul>
<li><code>Unordered sequential</code> files are called (pile files).</li>
<li><code>Sorted sequential</code> files (records are ordered by some field)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<h3 id="pile-files">Pile files:</h3>
<ul>
<li>are a <code>succession of records</code>, simply placed one after another with <code>no additional structure</code> Records may vary in length.</li>
<li>is the <code>best organization</code> for operations.</li>
<li>such as: Finding averages, min or max, or sum</li>
<li>They can be calculated <strong>using double buffering</strong> as we read though the file once.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<h4 id="to-look-up-a-record-given-the-value-of-one-or-more-of-its-fields-we-must-search-the-whole-file.">To look up a record, given the value of one or more of its fields, we must search the whole file.</h4>
</li>
<li>
<h4 id="in-order-to-search-for-a-record-i-have-to-search-for-it-in-the-entire-file">In order to search for a record, I have to search for it in the entire file</h4>
</li>
<li>
<h4 id="exhaustive-reading-of-the-file-is-read-and-process-all-records-reading-order-is-not-important."><code>Exhaustive Reading of the File</code> is Read and process all records (reading order is not important).</h4>
</li>
<li>
<h4 id="when-we-insert-a-new-record-it-will-be-placed-at-the-end-of-the-file-assuming-that-we-don’t-worry-about-duplicates">When we insert a new record, it will be placed at the end of the file (assuming that we don’t worry about duplicates)</h4>
</li>
</ul>
<hr>
<ul>
<li>
<h4 id="deleting-a-record">Deleting a record:</h4>
<ul>
<li>Operations like creating a file, adding records to a file and modifying a record can be performed physically by using basic file operations (open,seek, write, etc.)</li>
<li>What happens if records are deleted? There is <code>no basic operation</code> that allows us to “remove part of a file”.</li>
<li>Record deletion should be <code>taken care</code> of by the program responsible for file organization.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<h4 id="record-deletion-and-storage-compaction">Record deletion and Storage compaction:</h4>
<ul>
<li>Deletion can be done by “marking” a record as deleted (e.g., Place ‘*’ at the beginning of the record</li>
<li>The space for the record is not released, but the program <code>must include logic that checks if record is deleted or not</code></li>
<li>After a lot of records have been deleted, a special program is used to squeeze the file – this is called <code>Storage Compaction.</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<h4 id="deleting-fixed-length-records-and-reclaiming-space-dynamically.">Deleting fixed-length records and reclaiming space dynamically.</h4>
<ul>
<li>How to use the space of deleted records for storing records that are added later?
<ul>
<li>Use an <code>AVAIL LIST</code>, a linked list of available records</li>
<li>A header record (at the beginning of the file) stores the beginning of the AVAIL LIST.</li>
<li>When a record is deleted, it is marked as deleted and inserted into AVAIL LIST.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>    
<ul>
<li>
<h4 id="deleting-variable-length-records">Deleting variable length records</h4>
<ul>
<li>Use AVAIL LIST as before but <code>take care of the variable-length difficulties</code></li>
<li>The records in AVAIL LIST must <code>store its size as a field.</code> <code>Exact byte offset must be used.</code></li>
<li>Addition of records <code>must find a large enough record</code> in <code>AVAIL LIST</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<h4 id="there-are-several-placement-strategies-for-selecting-a-record-in-avail-list-when-adding-a-new-record">There are several placement strategies for selecting a record in AVAIL LIST when adding a new record:</h4>
<ul>
<li><code>First-fit Strategy:</code> AVAIL LIST is not sorted by size; first record large enough is used for the new record.</li>
<li><code>Best-fit Strategy:</code> List is sorted by size. Smallest record large enough is used</li>
<li><code>Worst-fit strategy:</code> List is sorted by decreasing order of size; largest record is used; unused space is placed in AVAIL LIST 21 again.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="rules">Rules</h3>
<ul>
<li>
<h4 id="b-is-the-total-number-of-blocks-in-the-file."><code>b</code> is the <code>total number of blocks</code> in the file.</h4>
</li>
<li>
<h4 id="if-the-record-is-at-the-beginning-of-the-file-then-at-least-1-block-is-accessed">If the record is at the <code>beginning</code> of the file, then at <code>least 1 block</code> is accessed</h4>
</li>
<li>
<h4 id="if-the-record-is-at-the-end-of-the-file-then-at-most-b-blocks-are-accessed">If the record is at the <code>end</code> of the file, then at most <code>b</code> blocks are accessed</h4>
</li>
<li>
<h4 id="on-average-b--2">On average b / 2</h4>
</li>
<li>
<h4 id="searching--time-to-find-and-read-a-record-in-a-pile-file-is--time-to-fetch-one-record--b2--effective-block-transfer-time">(searching) =&gt; Time to <code>find and read a record</code> in a pile file is =&gt; Time to <code>fetch</code> one record = (b/2) * effective block transfer time</h4>
</li>
<li>
<h4 id="reading-all-records--time-for-exhaustive-reading-of-the-file--seek-time--rotational-delay-time--b--time-to-transfer-one-block">(Reading all records) =&gt; Time for <code>exhaustive</code> reading of the file = seek time + rotational delay time + b * time to transfer one block</h4>
</li>
<li>
<h4 id="time-to-read-the-last-block--seek-time--rotational-delay-time--block-transfer-time">Time to <code>read the last block</code> = seek time + rotational delay time + block transfer time</h4>
</li>
<li>
<h4 id="time-to-insert-a-new-record--time-to-read-the-last-block--2r">Time to <code>insert a new record</code> = Time to read the last block + 2r</h4>
</li>
</ul>
<blockquote>
<p><strong>Note</strong><br>
(2r - block transfer time): <code>the time to wait for the disk</code> until it <code>rotates back to the original position</code></p>
</blockquote>
<blockquote>
<p><strong>Note</strong><br>
(Block transfer time): the time to <code>transfer the new record</code></p>
</blockquote>
<ul>
<li>
<h4 id="time-to-update-a-record-for-fixed-length-records--time-to-fetch-the-record--2r">Time to <code>update</code> a record for <code>fixed length</code> records = Time to fetch the record + 2r</h4>
</li>
<li>
<h4 id="time-to-update-a-record-for-variable-length-records--time-to-delete-the-record--time-to-insert-the-new-one">Time to <code>update</code> a record for <code>variable length</code> records = Time to delete the record + time to insert the new one</h4>
</li>
</ul>
</div>
</body>

</html>
