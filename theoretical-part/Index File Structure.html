<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Welcome file</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><ul>
<li>
<h4 id="an-index-is-a-table-containing-a-list-of-keys-associated-with-a-reference-field-pointing-to-the-record-where-the-information-referenced-by-the-key-can-be-found.">An index is a table containing a list of keys associated with a reference field pointing to the record where the information referenced by the key can be found.</h4>
</li>
<li>
<h4 id="an-index-lets-you-impose-order-on-a-file-without-rearranging-the-file"><code>An index</code> lets you impose order on a file <code>without rearranging the file</code></h4>
<ul>
<li><code>Data file:</code> It is not a requirement for the record to be in order</li>
<li><code>Index file:</code> The record must be in order</li>
</ul>
</li>
<li>
<h4 id="a-simple-index-is-simply-an-array-of-key-reference-pairs-which-is-ordered-by-the-field-of-the-file."><code>A simple index</code> is simply an array of (key, reference) pairs which is ordered by the field of the file.</h4>
<ul>
<li><code>Reference:</code> Stores the address of the record</li>
<li>Used to do direct access inside data file.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<h4 id="you-can-have-different-indexes-for-the-same-data-multiple-access-paths.">You can have different indexes for the same data: multiple access paths.</h4>
</li>
<li>
<h4 id="indexing-gives-us-keyed-access-to-variable-length-record-files"><code>Indexing</code> gives us <code>keyed access to variable-length record files</code></h4>
</li>
<li>
<h4 id="index-is-called-an-access-path-on-the-field"><code>Index</code> is called an <code>access path</code> on the field</h4>
</li>
<li>
<h4 id="the-index-file-occupies-less-disk-blocks-than-the-data-file-because-its-entries-are-much-smaller"><code>The index</code> file occupies <code>less disk blocks than</code> the data file because its entries are <code>much smaller</code></h4>
</li>
<li>
<h4 id="indexes-can-also-be-characterized-as-dense-or-sparse">Indexes can also be characterized as <code>dense</code> or <code>sparse</code></h4>
<ul>
<li><code>A dense index</code>: has an index entry for <code>every search key value</code> (every record) in the data file.</li>
<li><code>A Sparse index</code>: has an index entry <code>for only some search</code> key value (some records) in the data file.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<h4 id="types-of-single-level-indexes-primary-index-clustering-index-secondary-index">Types of single level indexes: <code>Primary index</code>, <code>Clustering index</code>, <code>Secondary index</code></h4>
</li>
<li>
<h4 id="an-example-of-a-simple-index-for-entry-sequenced-files-we-choose-to-organize-the-file-as-a-series-of-variable--length-records-with-a-size-field-preceding-each-record.">An Example of a Simple Index for Entry-Sequenced Files: We choose to organize the file as a series of variable- length records with a size field preceding each record.</h4>
</li>
<li>
<h4 id="the-fields-within-each-record-are-also-of-variable-length-but-are-separated-by-delimiters"><code>The fields within each record</code> are also of <code>variable-length</code> but are <code>separated by delimiters</code></h4>
</li>
<li>
<h4 id="we-form-a-primary-key-by-concatenating-the-record-company-label-code-and-the-record’s-id-number.-this-should-form-a-unique-identifier">We form a <code>primary key</code> by concatenating the record company label code and the record’s ID number. This should form a <code>unique identifier</code></h4>
</li>
<li>
<h4 id="in-order-to-provide-rapid-keyed-access-we-build-a-simple-index-with-a-key-field-associated-with-a-reference-field">In order to provide <code>rapid keyed access</code>, we build a <code>simple index</code> with a <code>key field</code> associated with a <code>reference field</code></h4>
</li>
<li>
<h4 id="reference-field-provides-the-address-of-the-first-byte-of-the-corresponding-data-record."><code>Reference field</code> provides the <code>address of the first byte</code> of the corresponding data record.</h4>
</li>
<li>
<h4 id="the-index-may-be-sorted-while-the-file-does-not-have-to-be.-this-means-that-the-data-file-may-be-entry-sequenced-the-record-occurs-in-the-order-they-are-entered-in-the-file.">The index may be sorted while the file does not have to be. This means that the data file may be <code>entry sequenced</code>: the record occurs in the order they are entered in the file.</h4>
</li>
</ul>
<hr>
<ul>
<li>
<h4 id="the-index-is-easier-to-use-than-the-data-file-because"><code>The index</code> is <code>easier to use than the data file</code> because</h4>
<ul>
<li>it uses <code>fixed-length records</code></li>
<li>It is likely to be much <code>smaller than the data file</code></li>
</ul>
</li>
<li>
<h4 id="by-requiring-fixed-length-records-in-the-index-file-we-impose-a-limit-on-the-size-of-the-primary-key-field.-this-could-cause-problems">By requiring fixed-length records in the index file, we impose a limit on the size of the primary key field. This could cause problems</h4>
</li>
<li>
<h4 id="the-index-could-carry-more-information-than-the-key-and-reference-fields-e.g.-we-could-keep-the-length-of-each-data-file-record-in-the-index-as-well">The index could <code>carry more information than</code> the <code>key and reference fields</code> (e.g., we could keep the length of each data file record in the index as well)</h4>
</li>
</ul>
<hr>
<ul>
<li>
<h4 id="assumption-index-is-small-enough-to-be-held-in-memory.">Assumption: <code>index is small enough</code> to be held in memory.</h4>
<ul>
<li><code>Create</code> the original empty index and data file.</li>
<li><code>Load</code> the index into memory <code>before using it</code></li>
<li><code>Rewrite</code> the index file from memory <code>after using it</code></li>
<li><code>Add</code> records to the data file and index</li>
<li><code>Delete</code> records from the data file</li>
<li><code>Update</code> records in the data file</li>
</ul>
</li>
<li>
<h4 id="the-index-is-represented-as-an-array-of-records">The index is represented <code>as an array of records</code></h4>
</li>
<li>
<h4 id="the-loading-into-memory-can-be-done-sequentially-reading-a-large-number-of-index-records-which-are-short-at-once"><code>The loading</code> into memory can be done <code>sequentially</code>, reading <code>a large number of index records</code> (which are short) <code>at once</code></h4>
</li>
<li>
<h4 id="what-happens-if-the-index-changes-but-its-rewriting-does-not-take-place-or-takes-place-incompletely">What happens <code>if the index changes</code>, but its <code>rewriting does not take place or takes place</code> incompletely?</h4>
<ul>
<li><code>Use a mechanism</code> for indicating whether or not the index is out of date.</li>
<li>Have a procedure that <code>reconstructs the index from the data file</code> in case it is out of date.</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<h4 id="when-we-add-a-record-both-the-data-file-and-the-index-should-be-updated">When we add a record, both the <code>data file and the index</code> should be <code>updated</code></h4>
</li>
<li>
<h4 id="in-the-data-file-the-record-can-be-added-anywhere-however-the-byte-offset-of-the-new-record-should-be-saved"><code>In the data file</code>, the record can be <code>added anywhere</code> However, the <code>byte-offset</code> of the new record should be <code>saved</code></h4>
</li>
<li>
<h4 id="since-the-u-the-location-of-the-new-record-does-matter">Since the u, the location of the new record does matter</h4>
<ul>
<li>we have to <code>shift all the records</code> that belong after the one we are inserting to open up space for the new record. However, <code>this operation is not too costly</code> as it is performed in memory</li>
</ul>
</li>
<li>
<h4 id="the-index-record-corresponding-to-the-data-record-being-deleted-must-also-be-deleted."><code>The index record</code> corresponding to <code>the data record</code> being deleted must also be deleted.</h4>
</li>
<li>
<h4 id="if-the-update-changes-the-value-of-the-key-field-then-both-the-index-and-data-file-may-need-to-be-reordered."><code>If the update changes the value of the key field</code>, then both the index and data file may need to be reordered.</h4>
</li>
<li>
<h4 id="if-the-update-does-not-affect-the-key-field-then-the-index-does-not-need-reordering-but-the-data-file-may."><code>If the update does not affect the key field</code>, then the index does not need reordering, but the data file may.</h4>
<ul>
<li>If the updated record is smaller than the original one, it can be re-written at the same location.</li>
<li>If it is larger, then a new spot has to be found for it. Again, the delete/insert solution can be 21 used</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<h4 id="if-indexes-are-too-large-to-hold-in-memory-then"><code>If Indexes are too large to hold in memory</code>, then</h4>
<ul>
<li><code>Binary searching requires several seeks</code> rather than being performed at memory speed.</li>
<li><code>Index rearrangement requires shifting or sorting records</code> on secondary storage ==&gt; Extremely time consuming.</li>
<li><code>Solutions:</code> You should
<ul>
<li>Use a <code>hashed</code> organization</li>
<li>Use a <code>tree-structured</code> index (e.g., a B-Tree)</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="example">Example</h4>
<ul>
<li>
<p>Given the following data file Employee (NAME, SSN, Address, JOB, ………………). Suppose that: <code>record size = 150 bytes</code>, <code>Block size = 512 bytes</code>, <code>Number of records in the file = 30000 Find number of file blocks</code>?</p>
<ul>
<li>Solu:
<ul>
<li>Blocking factor = number of records per block = Block size / record size = 512 / 150 = 3 records</li>
<li>Number of file blocks = number of records in the file / Blocking factor = 30000 / 3 = 10000</li>
</ul>
</li>
</ul>
</li>
<li>
<p>For an index on the SSN field. Assume the <code>SSN field size is 9 bytes</code>, and the record <code>pointer size is 7 bytes</code></p>
<ul>
<li>Solu:
<ul>
<li>Index entry size = 9 + 7 = 16 bytes</li>
<li>Blocking factor = 512 / 16 = 32 records</li>
<li>Number of file blocks = 30000 / 32 = 937 blocks</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

<table>
<thead>
<tr>
<th align="center">Primary Index</th>
<th align="center">Clustering Index</th>
<th align="center">Secondary Index</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Ordered ﬁle</td>
<td align="center">Ordered ﬁle</td>
<td align="center">Ordered ﬁle a secondary means of accessing a ﬁle.</td>
</tr>
<tr>
<td align="center">Data ﬁle is ordered on a key ﬁeld (distinct value for each record)</td>
<td align="center">Data ﬁle is ordered on a non-key ﬁeld (no distinct value for each record)</td>
<td align="center">Data ﬁle is ordered maybe on (1 - candidate key has a unique value), (2 - a non-key with duplicate values)</td>
</tr>
<tr>
<td align="center">One index entry for each disk block. key ﬁeld value is the ﬁrst record in the block, which is called the block anchor.</td>
<td align="center">One index entry for each distinct value of the ﬁeld. The index entry points to the ﬁrst data block that contains records with that ﬁeld value.</td>
<td align="center">The index is an ordered ﬁle with two ﬁelds: (1 - ﬁeld value.), (2 - it is either a block pointer or a record pointer.)</td>
</tr>
<tr>
<td align="center">Non dense (sparse) index</td>
<td align="center">Non dense (sparse) index</td>
<td align="center">If key -&gt; dense — If non key -&gt; dense or sparse index</td>
</tr>
</tbody>
</table></div>
</body>

</html>
